import xml

run(jack2vm_dir & '/../lib/xml_encode')

new_parser := proc(tokens, vm_file, xml_file) is
	parser := [
		'fout_vm' ~ io.open(vm_file, 'w'),
		'fout_xml' ~ io.open(xml_file, 'w'),
		'tokens' ~ tokens,
		'indentation' ~ 0,
		'tag_stack' ~ [],
		'variable_kind_to_segment' ~ [
			'static' ~ 'static',
			'field' ~ 'this',
			'argument' ~ 'argument',
			'var' ~ 'local'
		],
		'class_name' ~ null,
		'class_symbol_table' ~ new_symbol_table(),
		'subroutine' ~ null
	]

	#-- write some string in the xml out file
	proc parser@@xml_out(s) is
		io.writeline(self.fout_xml, strings.repeat('\t', self.indentation) & s)
	end

	#-- write into the vm file
	proc parser@@vm_out(s) is
		io.writeline(self.fout_vm, s)
	end

	#-- if t was 'keyword':'class', would print <keyword> class </keyword>
	proc parser@@print_token(t) is
		self@@xml_out('<' & t[1] & '> ' & xml_encode(t[2]) & ' </' & t[1] & '>')
	end

	proc parser@@parse(_) is
		self@@compile_class()
	end

	#-- pop a token and return its value if it matches one of the given parameters (strings) otherwise returns fail
	proc parser@@eat(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local token := bottom(self.tokens)
		for s in varargs do
			if isstring(s) and token.value == s then
				self@@print_token(token)
				pop bottom from self.tokens
				return s
			fi
		od
		error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & token.value & '".')
	end

	#-- returns weather or not eat(...) will fail
	proc parser@@edible(expected_strings) is
		local token := bottom(self.tokens)
		for s in expected_strings do
			if isstring(s) and token.value == s then
				return true, s
			fi
		od
		return false, token.value
	end

	proc parser@@assert_edible(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local edible, seen_token := self@@edible(varargs)
		if not edible then
			error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & seen_token & '".')
		fi
	end

	#-- if the current token is of the provided type, pop it and return it, otherwise throw an error
	proc parser@@eat_terminal(token_kind) is
		local token := bottom(self.tokens)
		if token.kind = token_kind then
			return self@@eat(token.value)
		fi
		error('Unexpected token: Expected a token of type "' & token_kind & '". Instead saw the ' & token.kind & ' "' & token.value & '".')
	end


	#-- call func as many times as possible until it throws an error
	proc parser@@zero_or_more(func) is
		local return_values := []
		do
			try
				insert func(self) into return_values
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				else
					return return_values
				fi
			yrt
		od
	end

	#-- call func once, and catch an error if it is an Unexpected token error
	proc parser@@zero_or_one(func) is
		try
			local temp := func(self)
			return temp
		catch msg then
			if not strings.isabbrev(msg, 'Unexpected token:', true) then
				error(msg)
			fi
		yrt
	end

	#-- opens an xml tag and stored its name on a stack
	proc parser@@open_tag(tag_name) is
		self@@xml_out('<' & tag_name & '>')
		insert tag_name into self.tag_stack
		inc self.indentation
	end

	#-- closes the xml tag on the top of the stack, and pops it
	proc parser@@close_tag(tag_name) is
		if tag_name <> null and tag_name <> top(self.tag_stack) then
			error('Expected to close <' & tag_name & '> but <' & top(self.tag_stack) & '> was left open')
		fi
		dec self.indentation
		self@@xml_out('</' & pop(self.tag_stack) & '>')
	end

	#-- 'class' <class_name> '{' <class_var>* <subroutine>* '}'
	proc parser@@compile_class(_) is
		self@@assert_edible('class')
		self@@open_tag('class')
		self@@eat('class')
		self.class_name := self@@compile_class_name()
		self@@eat('{')
		self@@zero_or_more(self.compile_class_var)
		self@@zero_or_more(self.compile_subroutine)
		self@@eat('}')
		self@@close_tag('class')
	end

	#-- any identifier is a valid class name
	proc parser@@compile_class_name(_) is
		return self@@eat_terminal('identifier')
	end

	#-- {'static' | 'field'} <type> <var_name> <another_var>* ';'
	proc parser@@compile_class_var(_) is
		self@@assert_edible('field', 'static')
		self@@open_tag('classVarDec')
		local segment := self.variable_kind_to_segment[self@@eat('field', 'static')]
		local var_type := self@@compile_type()
		local names := [self@@compile_var_name()]
		names := names union self@@zero_or_more(self.compile_another_var)
		#-- add to class symbols table
		for name in names do
			self.class_symbol_table@@add_symbol(var_type, name, segment)
		od

		self@@eat(';')
		self@@close_tag('classVarDec')
	end

	#-- ',' <var_name>
	proc parser@@compile_another_var(_) is
		self@@eat(',')
		return self@@compile_var_name()
	end

	#-- {'int' | 'char' | 'boolean' | <class_name> | 'void'}
	proc parser@@compile_type(allow_void) is
		allow_void := allow_void or false
		local token := null
		try
			#-- try the primitives first
			if allow_void then
				token := self@@eat('int', 'char', 'boolean', 'void')
				return token
			else
				token := self@@eat('int', 'char', 'boolean')
				return token
			fi
		catch msg then
			try
				#-- if primitives fail, try a class name
				token := self@@compile_class_name()
				return token
			catch
				token := bottom(self.tokens)
				error('Unexpected token: Expected a type (int, char, boolean, or a class name). Saw "' & token.value & '".')
			yrt
		yrt
	end

	#-- any identifier is a valid variable name
	proc parser@@compile_var_name(_) is
		return self@@eat_terminal('identifier')
	end

	#-- {'constructor' | 'method' | 'function'} {'void'|<type>} <subroutine_name> '(' <param_list> ')' <subroutine_body>
	proc parser@@compile_subroutine(_) is
		self@@assert_edible('constructor', 'method', 'function')
		self@@open_tag('subroutineDec')

		local subroutine_type := self@@eat('constructor', 'method', 'function')
		local return_type := self@@compile_type(true)
		local name := self@@compile_subroutine_name()

		#-- new_subroutine will add 'this' to symbol table if necessary
		self.subroutine := new_subroutine(subroutine_type, return_type, name, self.class_name)

		self@@eat('(')
		self@@compile_param_list()
		self@@eat(')')

		self@@compile_subroutine_body()

		self@@close_tag('subroutineDec')
	end

	#-- any identifier is a valid subroutine name
	proc parser@@compile_subroutine_name(_) is
		return self@@eat_terminal('identifier')
	end

	#-- [<param> (',' <param>)*]
	proc parser@@compile_param_list(_) is
		self@@open_tag('parameterList')
		local helper := proc() is
			self@@compile_param()
			local compile_more_params := proc() is
				self@@eat(',')
				self@@compile_param()
			end
			self@@zero_or_more(compile_more_params)
		end
		self@@zero_or_one(helper)
		self@@close_tag('parameterList')
	end

	#-- <type> <var_name>
	proc parser@@compile_param(_) is
		local var_type := self@@compile_type()
		local name := self@@compile_var_name()
		self.subroutine.symbol_table@@add_symbol(var_type, name, 'argument')
	end

	#-- '{' <local_var>* <statements> '}'
	proc parser@@compile_subroutine_body(_) is
		self@@assert_edible('{')
		self@@open_tag('subroutineBody')
		self@@eat('{')
		self@@zero_or_more(self.compile_local_var)

		#-- at this point we know enough about the subrouine to print its first part
		self@@vm_out(self.subrouine@@vm_intro())

		self@@compile_statements()
		self@@eat('}')
		self@@close_tag('subroutineBody')
	end

	#-- 'var' <type> <var_name> <another_var>* ';'
	proc parser@@compile_local_var(_) is
		self@@assert_edible('var')
		self@@open_tag('varDec')
		self@@eat('var')
		local var_type := self@@compile_type()
		local names := [self@@compile_var_name()]
		names := names union self@@zero_or_more(self.compile_another_var)
		#-- add to class symbols table
		for name in names do
			self.subroutine.symbol_table@@add_symbol(var_type, name, 'local')
		od

		self@@eat(';')
		self@@close_tag('varDec')
	end

	#-- <statement>*
	proc parser@@compile_statements(_) is
		self@@open_tag('statements')
		self@@zero_or_more(self.compile_statement)
		self@@close_tag('statements')
	end

	#-- {<let>|<if>|<while>|<do>|<return>}
	proc parser@@compile_statement(_) is
		for func in {self.compile_let, self.compile_if, self.compile_while, self.compile_do, self.compile_return} do
			try
				func(self)
				return
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				fi
			yrt
		od
		local token := bottom(self.tokens)
		error('Unexpected token: Expected the start of a statement, instead saw "' & token.value & '".')
	end

	#-- 'let' <var_name> <index>? '=' <expr> ';'
	proc parser@@compile_let(_) is
		self@@assert_edible('let')
		self@@open_tag('letStatement')
		self@@eat('let')
		self@@compile_var_name()
		self@@zero_or_one(self.compile_index)
		self@@eat('=')
		self@@compile_expr()
		self@@eat(';')
		self@@close_tag('letStatement')
	end

	#-- '[' <expr> ']'
	proc parser@@compile_index(_) is
		self@@eat('[')
		self@@compile_expr()
		self@@eat(']')
	end

	#-- 'if' '(' <expr> ')' '{' <statements> '}' <else>?
	proc parser@@compile_if(_) is
		self@@assert_edible('if')
		self@@open_tag('ifStatement')
		self@@eat('if')
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
		self@@zero_or_one(self.compile_else)
		self@@close_tag('ifStatement')
	end

	#-- 'else' '{' <statements> '}'
	proc parser@@compile_else(_) is
		self@@eat('else')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
	end

	#-- 'while' '(' <expr> ')' '{' <statements> '}'
	proc parser@@compile_while(_) is
		self@@assert_edible('while')
		self@@open_tag('whileStatement')
		self@@eat('while')
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
		self@@close_tag('whileStatement')
	end

	#-- 'do' <call> ';'
	proc parser@@compile_do(_) is
		self@@assert_edible('do')
		self@@open_tag('doStatement')
		self@@eat('do')
		self@@compile_call()
		self@@eat(';')
		self@@close_tag('doStatement')
	end

	#-- 'return' <expr>? ';'
	proc parser@@compile_return(_) is
		self@@assert_edible('return')
		self@@open_tag('returnStatement')
		self@@eat('return')
		self@@zero_or_one(self.compile_expr)
		self@@eat(';')
		self@@close_tag('returnStatement')
	end

	#-- <term> (<op> <term>)*
	proc parser@@compile_expr(_) is
		self@@assert_term_beginning()
		self@@open_tag('expression')
		self@@compile_term()
		local compile_more_terms := proc() is
			self@@compile_op()
			self@@compile_term()
		end
		self@@zero_or_more(compile_more_terms)
		self@@close_tag('expression')
	end

	proc parser@@assert_term_beginning(_) is
		local token := bottom(self.tokens)
		if not (token.kind in {'integerConstant', 'stringConstant', 'identifier'} or token.value in {'true', 'false', 'null', 'this', '(', '-', '~'}) then
			error('Unexpected token: Expected constant, identifier, unary operator, or opening parentheses. Instead saw "' & token.value & '".')
		fi
	end

	proc parser@@compile_term(_) is
		self@@assert_term_beginning()
		self@@open_tag('term')

		#-- first try the unambiguous paths
		for func in {self.compile_int, self.compile_str, self.compile_keyword_const, self.compile_parentheses, self.compile_unary_term} do
			try
				func(self)
				self@@close_tag('term')
				return
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				fi
			yrt
		od

		#-- if the previous loop hasnt returned, the next token is an identifier, which is ambiguous so we must look ahead
		local curr_token := bottom(self.tokens)
		if curr_token.kind <> 'identifier' then
			error('Unexpected token: Expected constant, identifier, unary operator, or opening parentheses. Instead saw "' & curr_token[2] & '".')
		fi
		pop bottom from self.tokens
		local next_token := bottom(self.tokens)
		if next_token.value = '[' then
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_subscript()
		elif next_token.value in {'.', '('} then
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_call()
		else
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_var_name()
		fi

		self@@close_tag('term')
	end

	#-- positive integer up to 32767
	proc parser@@compile_int(_) is
		self@@eat_terminal('integerConstant')
	end

	#-- double quoted sequence of unicode characters not including double quotes or newlines
	proc parser@@compile_str(_) is
		self@@eat_terminal('stringConstant')
	end

	#-- 'true' | 'false' | 'null' | 'this'
	proc parser@@compile_keyword_const(_) is
		self@@eat('true', 'false', 'null', 'this')
	end

	#-- '(' <expr> ')'
	proc parser@@compile_parentheses(_) is
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
	end

	#-- ('-' | '~') <term>
	proc parser@@compile_unary_term(_) is
		self@@eat('~', '-')
		self@@compile_term()
	end

	#-- <var_name> '[' <expr> ']'
	proc parser@@compile_subscript(_) is
		self@@eat_terminal('identifier')
		self@@eat('[')
		self@@compile_expr()
		self@@eat(']')
	end

	#-- ((<class_name> | <var_name>) '.')? <subroutine_name> '(' <expr_list>? ')'
	#-- equivalent to
	#-- <identifier> ('.' <identifier>)? '(' <expr_list> ')'
	proc parser@@compile_call(_) is
		self@@eat_terminal('identifier')
		try
			self@@eat('.')
			self@@eat_terminal('identifier')
		catch msg then
			if not strings.isabbrev(msg, 'Unexpected token:', true) then
				error(msg)
			fi
		yrt
		self@@eat('(')
		self@@zero_or_one(self.compile_expr_list)
		self@@eat(')')
	end

	#-- (<expr> (',' <expr>)*)?
	proc parser@@compile_expr_list(_) is
		self@@open_tag('expressionList')
		local helper1 := proc() is
			self@@compile_expr()
			local helper2 := proc() is
				self@@eat(',')
				self@@compile_expr()
			end
			self@@zero_or_more(helper2)
		end
		self@@zero_or_one(helper1)
		self@@close_tag('expressionList')
	end

	#-- '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='
	proc parser@@compile_op(_) is
		local temp := self@@eat('+', '-', '*', '/', ' ', '&', '|', '<', '>', '=')
	end

	return parser
end