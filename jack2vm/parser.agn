import xml

run(jack2vm_dir & '/../lib/xml_encode')

new_parser := proc(in_file, out_file, indent_str) is
	parser := [
		'fout' ~ io.open(out_file, 'w'),
		'tokens' ~ [],	#-- array of type:value pairs
		'indent_str' ~ indent_str or '\t',
		'indentation' ~ 0,
		'tag_stack' ~ [],
		'kind_to_segment' ~ [
			'static' ~ 'static',
			'field' ~ 'this',
			'argument' ~ 'argument',
			'var' ~ 'local'
		],
		'class_symbol_table' ~ new_symbol_table(),
		'procedure_symbol_table' ~ new_symbol_table()
	]

	#-- returns an array of type:value pairs from the tokenised XML file
	local file_contents := xml.decode(io.readfile(in_file))
	if file_contents = null then
		error('Error parsing XML file "' & in_file & '".')
	fi

	for i, tag in file_contents do
		skip when not isnumber(i)
		skip when not istable(tag)
		local t_type := tag.label
		local t_value := trim(tag[1])
		parser.tokens[size(parser.tokens) + 1] := t_type:t_value
	od

	#-- write some string in the out file
	#-- indents it according to the indentation class fields
	proc parser@@out(s) is
		io.writeline(self.fout, strings.repeat(self.indent_str, self.indentation) & s)
	end

	#-- if t was 'keyword':'class', would print <keyword> class </keyword>
	proc parser@@print_token(t) is
		self@@out('<' & t[1] & '> ' & xml_encode(t[2]) & ' </' & t[1] & '>')
	end

	proc parser@@parse(_) is
		self@@compile_class()
	end

	#-- pop a token and return its value if it matches one of the given parameters (strings) otherwise returns fail
	proc parser@@eat(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local token := bottom(self.tokens)
		for s in varargs do
			if isstring(s) and token[2] == s then
				self@@print_token(token)
				pop bottom from self.tokens
				return s
			fi
		od
		error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & token[2] & '".')
	end

	#-- returns weather or not eat(...) will fail
	proc parser@@edible(expected_strings) is
		local token := bottom(self.tokens)
		for s in expected_strings do
			if isstring(s) and token[2] == s then
				return true, s
			fi
		od
		return false, token[2]
	end

	proc parser@@assert_edible(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local edible, seen_token := self@@edible(varargs)
		if not edible then
			error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & seen_token & '".')
		fi
	end

	#-- if the current token is of the provided type, pop it and return it, otherwise throw an error
	proc parser@@eat_terminal(token_type) is
		local token := bottom(self.tokens)
		if token[1] = token_type then
			return self@@eat(token[2])
		fi
		error('Unexpected token: Expected a token of type "' & token_type & '". Instead saw the ' & token[1] & ' "' & token[2] & '".')
	end


	#-- call func as many times as possible until it throws an error
	proc parser@@zero_or_more(func) is
		local return_values := []
		do
			try
				insert func(self) into return_values
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				else
					return return_values
				fi
			yrt
		od
	end

	#-- call func once, and catch an error if it is an Unexpected token error
	proc parser@@zero_or_one(func) is
		try
			return func(self)
		catch msg then
			if not strings.isabbrev(msg, 'Unexpected token:', true) then
				error(msg)
			fi
		yrt
	end

	#-- opens an xml tag and stored its name on a stack
	proc parser@@open_tag(tag_name) is
		self@@out('<' & tag_name & '>')
		insert tag_name into self.tag_stack
		inc self.indentation
	end

	#-- closes the xml tag on the top of the stack, and pops it
	proc parser@@close_tag(tag_name) is
		if tag_name <> null and tag_name <> top(self.tag_stack) then
			error('Expected to close <' & tag_name & '> but <' & top(self.tag_stack) & '> was left open')
		fi
		dec self.indentation
		self@@out('</' & pop(self.tag_stack) & '>')
	end

	#-- 'class' <class_name> '{' <class_var>* <subroutine>* '}'
	proc parser@@compile_class(_) is
		self@@assert_edible('class')
		self@@open_tag('class')
		self@@eat('class')
		self@@compile_class_name()
		self@@eat('{')
		print('compile_class', 1)
		self@@zero_or_more(self.compile_class_var)
		print('compile_class', 2)
		self@@zero_or_more(self.compile_subroutine)
		print('compile_class', 3)
		self@@eat('}')
		self@@close_tag('class')
	end

	#-- any identifier is a valid class name
	proc parser@@compile_class_name(_) is
		return self@@eat_terminal('identifier')
	end

	#-- {'static' | 'field'} <type> <var_name> <more_vars>* ';'
	proc parser@@compile_class_var(_) is
		self@@assert_edible('field', 'static')
		self@@open_tag('classVarDec')
		local segment := self.kind_to_segment[self@@eat('field', 'static')]
		local var_type := self@@compile_type()
		#-- TODO: debug this
		local names := [self@@compile_var_name()]
		names := names union self@@zero_or_more(self.compile_more_vars)
		#-- add to class symbols table
		for name in names do
			print('compile_class_var', 1)
			print('class_symbol_table', self.class_symbol_table)
			self.class_symbol_table@@add_symbol(name, var_type, segment)
			print('compile_class_var', 2)
		od

		self@@eat(';')
		self@@close_tag('classVarDec')
	end

	#-- ',' <var_name>
	proc parser@@compile_more_vars(_) is
		self@@eat(',')
		return self@@compile_var_name()
	end

	#-- {'int' | 'char' | 'boolean' | <class_name> | 'void'}
	proc parser@@compile_type(allow_void) is
		allow_void := allow_void or false
		try
			#-- try the primitives first
			if allow_void then
				return self@@eat('int', 'char', 'boolean', 'void')
			else
				return self@@eat('int', 'char', 'boolean')
			fi
		catch
			try
				#-- if primitives fail, try a class name
				return self@@compile_class_name()
			catch
				local token := bottom(self.tokens)
				error('Unexpected token: Expected a type (int, char, boolean, or a class name). Saw "' & token[2] & '".')
			yrt
		yrt
	end

	#-- any identifier is a valid variable name
	proc parser@@compile_var_name(_) is
		return self@@eat_terminal('identifier')
	end

	#-- {'constructor' | 'method' | 'function'} {'void'|<type>} <subroutine_name> '(' <param_list> ')' <subroutine_body>
	proc parser@@compile_subroutine(_) is
		self@@assert_edible('constructor', 'method', 'function')
		self@@open_tag('subroutineDec')
		self@@eat('constructor', 'method', 'function')
		self@@compile_type(true)
		self@@compile_subroutine_name()
		self@@eat('(')
		self@@compile_param_list()
		self@@eat(')')
		self@@compile_subroutine_body()
		self@@close_tag('subroutineDec')
	end

	#-- any identifier is a valid subroutine name
	proc parser@@compile_subroutine_name(_) is
		self@@eat_terminal('identifier')
	end

	#-- [<type> <var_name> (',' <type> <var_name>)*]
	proc parser@@compile_param_list(_) is
		self@@open_tag('parameterList')
		local helper := proc() is
			self@@compile_type()
			self@@compile_var_name()
			local compile_more_params := proc() is
				self@@eat(',')
				self@@compile_type()
				self@@compile_var_name()
			end
			self@@zero_or_more(compile_more_params)
		end
		self@@zero_or_one(helper)
		self@@close_tag('parameterList')
	end

	#-- '{' <local_var>* <statements> '}'
	proc parser@@compile_subroutine_body(_) is
		self@@assert_edible('{')
		self@@open_tag('subroutineBody')
		self@@eat('{')
		self@@zero_or_more(self.compile_local_var)
		self@@compile_statements()
		self@@eat('}')
		self@@close_tag('subroutineBody')
	end

	#-- 'var' <type> <var_name> <more_vars>* ';'
	proc parser@@compile_local_var(_) is
		self@@assert_edible('var')
		self@@open_tag('varDec')
		self@@eat('var')
		self@@compile_type()
		self@@compile_var_name()
		self@@zero_or_more(self.compile_more_vars)
		self@@eat(';')
		self@@close_tag('varDec')
	end

	#-- <statement>*
	proc parser@@compile_statements(_) is
		self@@open_tag('statements')
		self@@zero_or_more(self.compile_statement)
		self@@close_tag('statements')
	end

	#-- {<let>|<if>|<while>|<do>|<return>}
	proc parser@@compile_statement(_) is
		for func in {self.compile_let, self.compile_if, self.compile_while, self.compile_do, self.compile_return} do
			try
				func(self)
				return
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				fi
			yrt
		od
		local token := bottom(self.tokens)
		error('Unexpected token: Expected the start of a statement, instead saw "' & token[2] & '".')
	end

	#-- 'let' <var_name> <index>? '=' <expr> ';'
	proc parser@@compile_let(_) is
		self@@assert_edible('let')
		self@@open_tag('letStatement')
		self@@eat('let')
		self@@compile_var_name()
		self@@zero_or_one(self.compile_index)
		self@@eat('=')
		self@@compile_expr()
		self@@eat(';')
		self@@close_tag('letStatement')
	end

	#-- '[' <expr> ']'
	proc parser@@compile_index(_) is
		self@@eat('[')
		self@@compile_expr()
		self@@eat(']')
	end

	#-- 'if' '(' <expr> ')' '{' <statements> '}' <else>?
	proc parser@@compile_if(_) is
		self@@assert_edible('if')
		self@@open_tag('ifStatement')
		self@@eat('if')
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
		self@@zero_or_one(self.compile_else)
		self@@close_tag('ifStatement')
	end

	#-- 'else' '{' <statements> '}'
	proc parser@@compile_else(_) is
		self@@eat('else')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
	end

	#-- 'while' '(' <expr> ')' '{' <statements> '}'
	proc parser@@compile_while(_) is
		self@@assert_edible('while')
		self@@open_tag('whileStatement')
		self@@eat('while')
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
		self@@eat('{')
		self@@compile_statements()
		self@@eat('}')
		self@@close_tag('whileStatement')
	end

	#-- 'do' <call> ';'
	proc parser@@compile_do(_) is
		self@@assert_edible('do')
		self@@open_tag('doStatement')
		self@@eat('do')
		self@@compile_call()
		self@@eat(';')
		self@@close_tag('doStatement')
	end

	#-- 'return' <expr>? ';'
	proc parser@@compile_return(_) is
		self@@assert_edible('return')
		self@@open_tag('returnStatement')
		self@@eat('return')
		self@@zero_or_one(self.compile_expr)
		self@@eat(';')
		self@@close_tag('returnStatement')
	end

	#-- <term> (<op> <term>)*
	proc parser@@compile_expr(_) is
		self@@assert_term_beginning()
		self@@open_tag('expression')
		self@@compile_term()
		local compile_more_terms := proc() is
			self@@compile_op()
			self@@compile_term()
		end
		self@@zero_or_more(compile_more_terms)
		self@@close_tag('expression')
	end

	proc parser@@assert_term_beginning(_) is
		local token := bottom(self.tokens)
		if not (token[1] in {'integerConstant', 'stringConstant', 'identifier'} or token[2] in {'true', 'false', 'null', 'this', '(', '-', '~'}) then
			error('Unexpected token: Expected constant, identifier, unary operator, or opening parentheses. Instead saw "' & token[2] & '".')
		fi
	end

	proc parser@@compile_term(_) is
		self@@assert_term_beginning()
		self@@open_tag('term')

		#-- first try the unambiguous paths
		for func in {self.compile_int, self.compile_str, self.compile_keyword_const, self.compile_parentheses, self.compile_unary_term} do
			try
				func(self)
				self@@close_tag('term')
				return
			catch msg then
				if not strings.isabbrev(msg, 'Unexpected token:', true) then
					error(msg)
				fi
			yrt
		od

		#-- if the previous loop hasnt returned, the next token is an identifier, which is ambiguous so we must look ahead
		local curr_token := bottom(self.tokens)
		if curr_token[1] <> 'identifier' then
			error('Unexpected token: Expected constant, identifier, unary operator, or opening parentheses. Instead saw "' & curr_token[2] & '".')
		fi
		pop bottom from self.tokens
		local next_token := bottom(self.tokens)
		if next_token[2] = '[' then
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_subscript()
		elif next_token[2] in {'.', '('} then
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_call()
		else
			#-- restore curr_token (index 1 is guaranteed to be empty)
			self.tokens[1] := curr_token
			self@@compile_var_name()
		fi

		self@@close_tag('term')
	end

	#-- positive integer up to 32767
	proc parser@@compile_int(_) is
		self@@eat_terminal('integerConstant')
	end

	#-- double quoted sequence of unicode characters not including double quotes or newlines
	proc parser@@compile_str(_) is
		self@@eat_terminal('stringConstant')
	end

	#-- 'true' | 'false' | 'null' | 'this'
	proc parser@@compile_keyword_const(_) is
		self@@eat('true', 'false', 'null', 'this')
	end

	#-- '(' <expr> ')'
	proc parser@@compile_parentheses(_) is
		self@@eat('(')
		self@@compile_expr()
		self@@eat(')')
	end

	#-- ('-' | '~') <term>
	proc parser@@compile_unary_term(_) is
		self@@eat('~', '-')
		self@@compile_term()
	end

	#-- <var_name> '[' <expr> ']'
	proc parser@@compile_subscript(_) is
		self@@eat_terminal('identifier')
		self@@eat('[')
		self@@compile_expr()
		self@@eat(']')
	end

	#-- ((<class_name> | <var_name>) '.')? <subroutine_name> '(' <expr_list>? ')'
	#-- equivalent to
	#-- <identifier> ('.' <identifier>)? '(' <expr_list> ')'
	proc parser@@compile_call(_) is
		self@@eat_terminal('identifier')
		try
			self@@eat('.')
			self@@eat_terminal('identifier')
		catch msg then
			if not strings.isabbrev(msg, 'Unexpected token:', true) then
				error(msg)
			fi
		yrt
		self@@eat('(')
		self@@zero_or_one(self.compile_expr_list)
		self@@eat(')')
	end

	#-- (<expr> (',' <expr>)*)?
	proc parser@@compile_expr_list(_) is
		self@@open_tag('expressionList')
		local helper1 := proc() is
			self@@compile_expr()
			local helper2 := proc() is
				self@@eat(',')
				self@@compile_expr()
			end
			self@@zero_or_more(helper2)
		end
		self@@zero_or_one(helper1)
		self@@close_tag('expressionList')
	end

	#-- '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='
	proc parser@@compile_op(_) is
		local temp := self@@eat('+', '-', '*', '/', ' ', '&', '|', '<', '>', '=')
	end

	return parser
end