import xml

new_parser := proc(in_file, out_file, indent_str) is
	parser := [
		'fout' ~ io.open(out_file, 'w'),
		'tokens' ~ [],	#-- array of type:value pairs
		'indent_str' ~ indent_str or '\t',
		'indentation' ~ 0,
		'tag_stack' ~ []
	]

	#-- returns an array of type:value pairs from the tokenised XML file
	local file_contents := xml.decode(io.readfile(in_file))
	if file_contents = null then
		error('Error parsing XML file "' & in_file & '".')
	fi

	for i, tag in file_contents do
		skip when not isnumber(i)
		skip when not istable(tag)
		local t_type := tag.label
		local t_value := trim(tag[1])
		parser.tokens[size(parser.tokens) + 1] := t_type:t_value
	od

	#-- write some string in the out file
	#-- indents it according to the indentation class fields
	proc parser@@out(s) is
		io.writeline(self.fout, strings.repeat(self.indent_str, self.indentation) & s)
	end

	#-- if t was 'keyword':'class', would print <keyword> class </keyword>
	proc parser@@print_token(t) is
		self@@out('<' & t[1] & '> ' & t[2] & ' </' & t[1] & '>')
	end

	proc parser@@parse(_) is
		self@@compile_class()
	end

	#-- pop a token and return its value if it matches one of the given parameters (strings) otherwise returns fail
	proc parser@@eat(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local token := bottom(self.tokens)
		for s in varargs do
			if isstring(s) and token[2] == s then
				self@@print_token(token)
				pop bottom from self.tokens
				return s
			fi
		od
		error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & token[2] & '".')
	end

	#-- returns weather or not eat(...) will fail
	proc parser@@edible(expected_strings) is
		local token := bottom(self.tokens)
		for s in expected_strings do
			if isstring(s) and token[2] == s then
				return true, s
			fi
		od
		return false, token[2]
	end

	proc parser@@assert_edible(_, ?) is
		varargs := varargs or []
		insert _ into varargs
		local edible, seen_token := self@@edible(varargs)
		if not edible then
			error('Unexpected token: Expected one of ' & tostringx(varargs) & '. Instead saw "' & seen_token & '".')
		fi
	end

	#-- if the current token is an identifier, pop it and return its name, otherwise fail
	proc parser@@eat_identifier(_) is
		local token := bottom(self.tokens)
		if token[1] = 'identifier' then
			return self@@eat(token[2])
		fi
		error('Unexpected token: Expected an identifier. Instead saw the ' & token[1] & ' "' & token[2] & '".')
	end

	#-- call func as many times as possible until it throws an error
	proc parser@@zero_or_more(func) is
		self@@zero_or_one(<< (func) -> do func(self) od >>)
	end

	#-- call func once, and catch an error if it is an Unexpected token error
	proc parser@@zero_or_one(func) is
		try
			func(self)
		catch msg then
			if not strings.isabbrev(msg, 'Unexpected token:', true) then
				error(msg)
			fi
		yrt
	end

	#-- opens an xml tag and stored its name on a stack
	proc parser@@open_tag(tag_name) is
		self@@out('<' & tag_name & '>')
		insert tag_name into self.tag_stack
		inc self.indentation
	end

	#-- closes the xml tag on the top of the stack, and pops it
	proc parser@@close_tag() is
		self@@out('</' & top(self.tag_stack) & '>')
		pop top from self.tag_stack
		dec self.indentation
	end

	#-- 'class' <class_name> '{' <class_var>* <subroutine>* '}'
	proc parser@@compile_class(_) is
		self@@assert_edible('class')
		self@@open_tag('class')
		self@@eat('class')
		self@@compile_class_name()
		self@@eat('{')
		self@@zero_or_more(self.compile_class_var)
		self@@zero_or_more(self.compile_subroutine)
		self@@eat('}')
		self@@close_tag()
	end

	#-- any identifier is a valid class name
	proc parser@@compile_class_name(_) is
		self@@eat_identifier()
	end

	#-- {'static'|'field'} <type> <var_name> <more_vars>* ';'
	proc parser@@compile_class_var(_) is
		self@@assert_edible('field', 'static')
		self@@open_tag('classVarDec')
		self@@eat('field', 'static')
		self@@compile_type()
		self@@compile_var_name()
		self@@zero_or_more(self.compile_more_vars)
		self@@eat(';')
		self@@close_tag()
	end

	#-- ',' <var_name>
	proc parser@@compile_more_vars(_) is
		self@@eat(',')
		self@@compile_var_name()
	end

	#-- {'int'|'char'|'boolean'|<class_name>}
	proc parser@@compile_type(allow_void) is
		allow_void := allow_void or false
		try
			#-- try the primitives first
			if allow_void then
				self@@eat('int', 'char', 'boolean', 'void')
			else
				self@@eat('int', 'char', 'boolean')
			fi
		catch
			try
				#-- if primitives fail, try a class name
				self@@compile_class_name()
			catch
				local token := bottom(self.tokens)
				error('Unexpected token: Expected a type (int, char, boolean, or a class name). Saw "' & token[2] & '".')
			yrt
		yrt
	end

	#-- any identifier is a valid variable name
	proc parser@@compile_var_name(_) is
		self@@eat_identifier()
	end

	#-- {'constructor'|'method'|'function'} {'void'|<type>} <subroutine_name> '(' <param_list> ')' <subroutine_body>
	proc parser@@compile_subroutine(_) is
		self@@assert_edible('constructor', 'method', 'function')
		self@@open_tag('subroutineDec')
		self@@compile_type(true)
		self@@compile_subroutine_name()
		self@@eat('(')
		self@@compile_param_list()
		self@@eat(')')
		self@@compile_subroutine_body()
		self@@close_tag()
	end

	#-- any identifier is a valid subroutine name
	proc parser@@compile_subroutine_name(_) is
		self@@eat_identifier()
	end

	#-- [<type> <var_name> (',' <type> <var_name>)*]
	proc parser@@compile_param_list(_) is
		self@@open_tag('parameterList')
		local helper := proc() is
			self@@compile_type()
			self@@compile_var_name()
			local compile_more_params := proc() is
				self@@compile_type()
				self@@compile_var_name()
			end
			self@@zero_or_more(compile_more_params)
		end
		self@@zero_or_one(helper)
		self@@close_tag()
	end

	#-- '{' <local_var>* <statements> '}'
	proc parser@@compile_subroutine_body(_) is
		self@@assert_edible('{')
		self@@open_tag('subroutineBody')
		self@@eat('{')
		self@@zero_or_more(self.compile_local_var)
		self@@compile_statements()
		self@@eat('}')
		self@@close_tag()
	end

	#-- 'var' <type> <var_name> <more_vars>* ';'
	proc parser@@compile_local_var(_) is
		self@@assert_edible('var')
		self@@open_tag('varDec')
		self@@eat('var')
		self@@compile_type()
		self@@compile_var_name()
		self@@zero_or_more(self.compile_more_vars)
		self@@eat(';')
		self@@close_tag()
	end

	#--
	proc parser@@compile_statements() is
		#-- TODO
	end

	return parser
end