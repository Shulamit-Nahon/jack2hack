asm_gen := [
	seg_ptr_addr = [
		'local' ~ 1,
		'argument' ~ 2,
		'this' ~ 3,
		'that' ~ 4
	],
	sp = 0,
	stack = 256
]

proc asm_gen@@out(str) is
	str := if str then str else '' fi
	io.writeline(self.fout, str)
end

proc asm_gen@@init(fout_name) is
	self.fout := io.open(fout_name, 'w')
	self.file_base_name := (pop(fout_name split '/') split '.asm')[1]
	self@@init_mem()
end

proc asm_gen@@destruct(_) is
	io.close(self.fout)
end

proc asm_gen@@init_mem(_) is
	# set stack pointer (stored in RAM[0]) to address 256
	self@@set_mem(self.sp, self.stack)

	# set local to address 2048
	self@@set_mem(self.seg_ptr_addr['local'], 2048)
	# set argument to address 2148
	self@@set_mem(self.seg_ptr_addr['argument'], 2148)
	# set this to address 2248
	self@@set_mem(self.seg_ptr_addr['this'], 2248)
	# set that to address 2348
	self@@set_mem(self.seg_ptr_addr['that'], 2348)

	self@@out()
end

proc asm_gen@@set_mem(index, value) is
	self@@out('@' & value)
	self@@out('D=A')
	self@@out('@' & index)
	self@@out('M=D')
end

proc asm_gen@@get_seg_ptr_addr(segment) is
	local ptr_addr := self.seg_ptr_addr[segment]
	if not ptr_addr then
		error('Unknown could not find pointer of segment "' & segment & '".')
	fi
	return ptr_addr
end

# generate assembly for a push command
proc asm_gen@@gen_push(segment, i) is
	self@@out('// push ' & segment & ' ' & i)

	if segment = 'constant' then
		self@@push_constant(i)
	elif segment = 'static' then
		self@@push_static(i)
	elif segment = 'temp' then
		self@@push_temp(i)
	elif segment = 'pointer' then
		self@@push_pointer(i)
	else
		self@@push_latt(self@@get_seg_ptr_addr(segment), i)
	fi

	self@@out()
end

# generate assembly for a pop command
proc asm_gen@@gen_pop(segment, i) is
	self@@out('// pop ' & segment & ' ' & i)

	if segment = 'static' then
		self@@pop_static(i)
	elif segment = 'temp' then
		self@@pop_temp(i)
	elif segment = 'pointer' then
		self@@pop_pointer(i)
	else
		self@@pop_latt(self@@get_seg_ptr_addr(segment), i)
	fi

	self@@out()
end

# function that produces assembly to put contents of D register onto stack (overwrites A register)
proc asm_gen@@push_d_register(_) is
	# load SP into A register
	self@@out('@' & self.sp)
	self@@out('A=M')

	# store i (now in D register) into RAM[SP]
	self@@out('M=D')

	# increment stack pointer
	self@@out('@' & self.sp)
	self@@out('M=M+1')
end

# function that produces assembly to pop top of stack into D register (overwrites A register)
proc asm_gen@@pop_d_register(_) is
	# decrement stack pointer
	self@@out('@' & self.sp)
	self@@out('M=M-1')

	# load SP into A register
	self@@out('A=M')

	# store RAM[SP] into D register
	self@@out('M=D')
end

# push local, argument, this, or that
proc asm_gen@@push_latt(ptr_addr, i) is
	# set D to segment address
	self@@out('@' & ptr_addr)
	self@@out('D=M')

	# set A to i
	self@@out('@' & i)

	# add base and offset
	self@@out('A=D+A')

	# dereference calculated address
	self@@out('D=M')

	self@@push_d_register()
end

# pop local, argument, this, or that
proc asm_gen@@pop_latt(ptr_addr, i) is
	# set D to segment address
	self@@out('@' & ptr_addr)
	self@@out('D=M')

	# set A to i
	self@@out('@' & i)

	# add base and offset
	self@@out('D=D+A')

	# put address in R13
	self@@out('@13')
	self@@out('M=D')

	self@@pop_d_register()

	# get address from R13 into A
	self@@out('@13')
	self@@out('A=M')

	# store D (equal to top of stack) in RAM[address]
	self@@out('M=D')
end

proc asm_gen@@push_constant(i) is
	# load i into D register
	self@@out('@' & i)
	self@@out('D=A')

	self@@push_d_register()
end

proc asm_gen@@push_static(i) is
	self@@out('@' & self.file_base_name & '.' & i)
	self@@out('D=M')
	self@@push_d_register()
end

proc asm_gen@@push_temp(i) is
	if i > 8 then
		error('Offset out of bounds. Offset "' & i & '" cannot be greater than 8.')
	fi

	# load base into D register
	self@@out('@' & 5)
	self@@out('D=A')

	# load offset into A register
	self@@out('@' & i)

	# load base plus offset sum to A register
	self@@out('A=D+A')

	# load contents of base plus offset in D register
	self@@out('D=M')

	self@@push_d_register()
end

proc asm_gen@@push_pointer(i) is
	if i < 0 or i > 1 then
		error('Pointer segment offset must be 1 or 0.')
	fi
	# load contents of this into D register
	self@@out('@' & 3 + i)
	self@@out('D=M')

	self@@push_d_register()
end

proc asm_gen@@gen_add(_) is
	print('adding')
end