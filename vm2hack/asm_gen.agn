run 'label_maker.agn'

asm_gen := [
	seg_ptr_addr = [
		'local' ~ 1,
		'argument' ~ 2,
		'this' ~ 3,
		'that' ~ 4
	],
	sp = 0,
	stack = 256,
	label_maker = new_label_maker()
]

proc asm_gen@@out(str) is
	str := if str then str else '' fi
	io.writeline(self.fout, str)
end

proc asm_gen@@init(fout_name) is
	self.fout := io.open(fout_name, 'w')
	self.file_base_name := (pop(fout_name split '/') split '.asm')[1]
	self@@init_mem()
end

proc asm_gen@@destruct(_) is
	io.close(self.fout)
end

proc asm_gen@@init_mem(_) is
	# set stack pointer (stored in RAM[0]) to address 256
	self@@set_mem(self.sp, self.stack)

	# set local to address 2048
	self@@set_mem(self.seg_ptr_addr['local'], 2048)
	# set argument to address 2148
	self@@set_mem(self.seg_ptr_addr['argument'], 2148)
	# set this to address 2248
	self@@set_mem(self.seg_ptr_addr['this'], 2248)
	# set that to address 2348
	self@@set_mem(self.seg_ptr_addr['that'], 2348)

	self@@out()
end

proc asm_gen@@set_mem(index, value) is
	self@@out('@' & value)
	self@@out('D=A')
	self@@out('@' & index)
	self@@out('M=D')
end

proc asm_gen@@get_seg_ptr_addr(segment) is
	local ptr_addr := self.seg_ptr_addr[segment]
	if not ptr_addr then
		error('Unknown could not find pointer of segment "' & segment & '".')
	fi
	return ptr_addr
end

# generate assembly for a push command
proc asm_gen@@gen_push(segment, i) is
	self@@out('// push ' & segment & ' ' & i)

	if segment = 'constant' then
		self@@push_constant(i)
	elif segment = 'static' then
		self@@push_static(i)
	elif segment = 'temp' then
		self@@push_temp(i)
	elif segment = 'pointer' then
		self@@push_pointer(i)
	else
		self@@push_latt(self@@get_seg_ptr_addr(segment), i)
	fi

	self@@out()
end

# generate assembly for a pop command
proc asm_gen@@gen_pop(segment, i) is
	self@@out('// pop ' & segment & ' ' & i)

	if segment = 'static' then
		self@@pop_static(i)
	elif segment = 'temp' then
		self@@pop_temp(i)
	elif segment = 'pointer' then
		self@@pop_pointer(i)
	else
		self@@pop_latt(self@@get_seg_ptr_addr(segment), i)
	fi

	self@@out()
end

# function that produces assembly to put contents of D register onto stack (overwrites A register)
proc asm_gen@@push_d_register(_) is
	# load SP into A register
	self@@out('@' & self.sp)
	self@@out('A=M')

	# store i (now in D register) into RAM[SP]
	self@@out('M=D')

	# increment stack pointer
	self@@out('@' & self.sp)
	self@@out('M=M+1')
end

# function that produces assembly to pop top of stack into D or A register (overwrites A register)
proc asm_gen@@pop_register(r) is
	if r <> 'D' and r <> 'A' then
		error(r & ' is not a register.')
	fi

	# decrement stack pointer
	self@@out('@' & self.sp)
	self@@out('M=M-1')

	# load SP into A register
	self@@out('A=M')

	# store RAM[SP] into D register
	self@@out(r & '=M')
end

# push local, argument, this, or that
proc asm_gen@@push_latt(ptr_addr, i) is
	# set D to segment address
	self@@out('@' & ptr_addr)
	self@@out('D=M')

	# set A to i
	self@@out('@' & i)

	# add base and offset
	self@@out('A=D+A')

	# dereference calculated address
	self@@out('D=M')

	self@@push_d_register()
end

# pop local, argument, this, or that
proc asm_gen@@pop_latt(ptr_addr, i) is
	# set D to segment address
	self@@out('@' & ptr_addr)
	self@@out('D=M')

	# set A to i
	self@@out('@' & i)

	# add base and offset
	self@@out('D=D+A')

	# put address in R13
	self@@out('@13')
	self@@out('M=D')

	self@@pop_register('D')

	# get address from R13 into A
	self@@out('@13')
	self@@out('A=M')

	# store D (equal to top of stack) in RAM[address]
	self@@out('M=D')
end

proc asm_gen@@push_constant(i) is
	# load i into D register
	self@@out('@' & i)
	self@@out('D=A')

	self@@push_d_register()
end

proc asm_gen@@push_static(i) is
	self@@out('@' & self.file_base_name & '.' & i)
	self@@out('D=M')
	self@@push_d_register()
end

proc asm_gen@@push_temp(i) is
	if i > 8 then
		error('Offset out of bounds. Offset "' & i & '" cannot be greater than 8.')
	fi

	# load base into D register
	self@@out('@' & 5)
	self@@out('D=A')

	# load offset into A register
	self@@out('@' & i)

	# load base plus offset sum to A register
	self@@out('A=D+A')

	# load contents of base plus offset in D register
	self@@out('D=M')

	self@@push_d_register()
end

proc asm_gen@@push_pointer(i) is
	if i < 0 or i > 1 then
		error('Pointer segment offset must be 1 or 0.')
	fi
	# load contents of this into D register
	self@@out('@' & 3 + i)
	self@@out('D=M')

	self@@push_d_register()
end

# generate assembly to put the address to the top of stack into A register
proc asm_gen@@point_to_stack_top(_) is
	self@@out('@' & self.sp)
	self@@out('A=M-1')
end

proc asm_gen@@gen_add(_) is
	self@@out('// add')

	# place first value into D register
	self@@pop_register('D')

	# place address to second value (SP-1) in A register
	self@@point_to_stack_top()

	# add first value (from D register) to second value (directly in memory)
	self@@out('M=D+M')

	self@@out()
end

proc asm_gen@@gen_sub(_) is
	self@@out('// sub')

	# place first value into D register
	self@@pop_register('D')

	# place address to second value (SP-1) in A register
	self@@point_to_stack_top()

	# subtract first value (from D register) from second value (directly in memory)
	self@@out('M=M-D')

	self@@out()
end

proc asm_gen@@gen_neg(_) is
	self@@out('// neg')

	# load address of topmost element into A
	self@@point_to_stack_top()

	# top element = -top element
	self@@out('M=-M')

	self@@out()
end

proc asm_gen@@gen_eq(_) is
	self@@out('// eq')

	# take one value from stack into D register and decrement SP
	self@@pop_register('D')

	# make A register point to topmost stack element
	self@@point_to_stack_top()

	# subtract D from top
	self@@out('D=M-D')

	local label_eq := self.label_maker@@make_label()
	local label_end := self.label_maker@@make_label()

	# if D equals 0 (i.e. if values are equal), jump to label_eq
	self@@out('@' & label_eq)
	self@@out('D;JEQ')

	# if values are not equal, replace top of stack with 0
	self@@point_to_stack_top()
	self@@out('M=0')

	# then jump to end of block
	self@@out('@' & label_end)
	self@@out('0;JMP')

	# define label_eq
	self@@out('(' & label_eq & ')')

	# replace top of stack with TRUE
	self@@point_to_stack_top()
	self@@out('M=-1')

	# define label_end
	self@@out('(' & label_end & ')')

	self@@out()
end

proc asm_gen@@gen_gt(_) is
	self@@out('// gt')
	# TODO

	self@@out()
end

proc asm_gen@@gen_lt(_) is
	self@@out('// lt')
	# TODO

	self@@out()
end

proc asm_gen@@gen_and(_) is
	self@@out('// and')
	# TODO

	self@@out()
end

proc asm_gen@@gen_or(_) is
	self@@out('// or')
	# TODO

	self@@out()
end

proc asm_gen@@gen_not(_) is
	self@@out('// not')

	self@@point_to_stack_top()

	#inverts all bits
	self@@out('M=!M')


	self@@out()
end
