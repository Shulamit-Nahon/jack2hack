asm_gen := [
	seg_ptr_addr = [
		'local' ~ 1,
		'argument' ~ 2,
		'this' ~ 3,
		'that' ~ 4
	],
	sp = 0,
	stack = 256
]

proc asm_gen@@out(str) is
	io.writeline(self.fout, str)
end

proc asm_gen@@init(fout_name) is
	self.fout := io.open(fout_name, 'w')
	self@@init_mem()
end

proc asm_gen@@init_mem() is
	# set stack pointer (stored in RAM[0]) to address 256
	self@@set_mem(self.sp, self.stack)

	# set local to address 2048
	self@@set_mem(self.seg_ptr_addr['local'], 2048)
	# set argument to address 2148
	self@@set_mem(self.seg_ptr_addr['argument'], 2148)
	# set this to address 2248
	self@@set_mem(self.seg_ptr_addr['this'], 2248)
	# set that to address 2348
	self@@set_mem(self.seg_ptr_addr['that'], 2348)

	io.writeline(fout)
end

proc asm_gen@@set_mem(index, value) is
	self@@out('@' & value)
	self@@out('D=A')
	self@@out('@' & index)
	self@@out('M=D')
end

# function that produces assembly to put contents of D register onto stack (overwrites A register)
proc asm_gen@@push_d_register(fout) is
	# load SP into A register
	self@@out('@' & self.sp)
	self@@out('A=M')

	# store i (now in D register) into RAM[SP]
	self@@out('M=D')

	# increment stack pointer
	self@@out('@' & self.sp)
	self@@out('M=M+1')
end

proc asm_gen@@push(fout, segment, i) is
	self@@out('// push ' & segment & ' ' & i)

	if segment = 'constant' then
		self@@push_constant(fout, i)
		return
	elif segment = 'static' then
		self@@push_static(fout, i)
		return
	elif segment = 'temp' then
		self@@push_temp(fout, i)
		return
	elif segment = 'pointer' then
		self@@push_pointer(fout, i)
		return
	elif not segment in ['local', 'this', 'that', 'argument'] then
		error('Unrecognised segment name "' & segment & '".')
	fi

	local ptr_addr := self.seg_ptr_addr[segment]

	# set D to segment address
	self@@out('@' & ptr_addr)
	self@@out('D=M')

	# set A to i
	self@@out('@' & i)

	# add base and offset
	self@@out('A=D+A')

	# dereference calculated address
	self@@out('D=M')

	self@@push_d_register(fout)

	io.writeline(fout)
end

proc asm_gen@@push_constant(fout, i) is
	# load i into D register
	self@@out('@' & i)
	self@@out('D=A')

	self@@push_d_register(fout)

	io.writeline(fout)
end

proc asm_gen@@push_static(fout, i) is

end