parser := [
	'command_table' ~ [],
	'segments' ~ [
		'local',
		'argument',
		'this',
		'that',
		'constant',
		'static',
		'temp',
		'pointer'
	]
]

proc parser@@parse_stack_ops(remainder) is
	local segment, i := strings.cut(remainder, ' ')
	if segment in self.segments then
		i := tonumber(i)
		return segment, i
	fi
	error('Unrecognised segment name "' & segment & '".')
end

proc parser@@parse_push(remainder) is
	local segment, i := self@@parse_stack_ops(remainder)
	asm_gen@@push(segment, i)
end

proc parser@@parse_pop(remainder) is
	local segment, i := self@@parse_stack_ops(remainder)
	if segment = 'constant' then
		error('Instruction "pop constant" is illegal.')
	fi
	asm_gen@@gen_pop(segment, i)
end

proc parser@@parse_line(line) is
	line := trim(replace(line, '\t', ' '))
	local command, remainder := strings.cut(line, ' ')	# splits line on first space
	self.command_table[command](self, remainder)
end

parser.command_table['push'] := parser.parse_push
parser.command_table['pop'] := parser.parse_pop

parser.command_table['add'] := asm_gen.gen_add
parser.command_table['sub'] := asm_gen.gen_sub
parser.command_table['neg'] := asm_gen.gen_neg
parser.command_table['eq'] := asm_gen.gen_eq
parser.command_table['gt'] := asm_gen.gen_gt
parser.command_table['lt'] := asm_gen.gen_lt
parser.command_table['and'] := asm_gen.gen_and
parser.command_table['or'] := asm_gen.gen_or
parser.command_table['not'] := asm_gen.gen_not

parser.command_table['label'] := parser.label
parser.command_table['goto'] := parser.goto
parser.command_table['if_goto'] := parser.if_goto
